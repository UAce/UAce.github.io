<!DOCTYPE html> <html lang="en-US"> <head> <title>How to Setup Ambassador Edge Stack's Automatic TLS with ACME - UAce</title> <meta name="google-site-verification" content="HSKSURZsT6ZUCdOqCx8SBhp4jD-paLVBxYIiDeN3RHs"/> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale = 1.0, maximum-scale=1.0, user-scalable=no"/> <meta name="apple-mobile-web-app-capable" content="yes"/> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha384-Q8BgkilbsFGYNNiDqJm69hvDS7NCJWOodvfK/cwTyQD4VQA0qKzuPpvqNER1UC0F" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/zenburn.min.css"> <link rel="stylesheet" href="/assets/css/style.css"> <link rel="shortcut icon" class="favicon" type="image/svg" href="/assets/images/UA_favicon_dark.svg"> <script src="/assets/js/check-dark-theme.js"></script> <script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu//q5B/lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-168212953-1"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-168212953-1");</script> <title>How to Setup Ambassador Edge Stack’s Automatic TLS with ACME | UAce</title> <meta name="generator" content="Jekyll v3.8.7"/> <meta property="og:title" content="How to Setup Ambassador Edge Stack’s Automatic TLS with ACME"/> <meta name="author" content="Yu-Yueh Liu"/> <meta property="og:locale" content="en_US"/> <meta name="description" content="At my current company Ormuco Inc., we use Ambassador Edge Stack (AES) as our Kubernetes-native API Gateway with HTTPS enabled and TLS termination. Until recently, we had been generating certificates using Certbot and renewing them with automated scripts. In this article, I will walk you through a better way to manage certificates in Kubernetes using Ambassador Edge Stack’s automatic TLS with ACME. Prerequisites This tutorial requires you have the following: A Kubernetes cluster A domain name Ambassador Edge Stack deployed in your cluster (see here) Your domain name pointing to the Ambassador LoadBalancer’s external IP What is Ambassador Automatic TLS? The Ambassador Edge Stack has simple and easy built-in support for automatically using ACME to create and renew TLS certificates; configured by the Host resource. However, it only supports ACME’s http-01 challenge; if you require more flexible certificate management (such as using ACME’s dns-01 challenge, or using a non-ACME certificate source), the Ambassador Edge stack also supports using external certificate management tools. One such tool is Jetstack’s cert-manager, which is a general-purpose tool for managing certificates in Kubernetes. Cert-manager will automatically create and renew TLS certificates and store them as Kubernetes secrets for easy use in a cluster. The Ambassador Edge Stack will automatically watch for secret changes and reload certificates upon renewal. Essentially, we can deploy Cert-Manager to manage certificates in Kubernetes for us. Ambassador only supports HTTP-01 challenge but it’s possible to perform DNS-01 challenge using Cert-Manager. Note: We use GoDaddy domain names and it is not a supported DNS Provider (see list of supported providers). There are several Cert-Manager Godaddy Webhook implementations online but they don’t seem to be well maintained so I decided to stick with HTTP-01 challenge. How to Setup Automatic TLS with ACME? For tutorial, I will be using an arbitrary email my-email@gmail.com and Let’s Encrypt to Issue a certificate for an arbitrary domain name dev.mydomain.com. Install the Cert-Manager tool with kubectl Let’s start by installing the Cert-Manager tool that will manage our certificates. # Install Custom Resource Definitions and Cert-Manager kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml Note: You can also install Cert-Manager with Helm (see here) Create a ClusterIssuer resource An Issuer or ClusterIssuer identifies which Certificate Authority cert-manager will use to issue a certificate. Issuer is a namespaced resource allowing you to use different CAs in each namespace, a ClusterIssuer is used to issue certificates in any namespace. Configuration depends on which ACME challenge you are using. Once the Cert-manager deployments are completed, you can create a ClusterIssuer (global) or an Issuer (namespaced) resource. In this case, we are using Let’s Encrypt. --- apiVersion: cert-manager.io/v1alpha2 kind: ClusterIssuer metadata: name: letsencrypt-prod spec: acme: # Replace this email address with your own. # Let&#39;s Encrypt will use this to contact you about expiring # certificates, and issues related to your account. email: my-email@gmail.com # ACME URL, you can use the URL for Staging environment to Issue untrusted certificates server: https://acme-v02.api.letsencrypt.org/directory privateKeySecretRef: # Secret resource that will be used to store the account&#39;s private key. name: issuer-account-private-key solvers: # Define the solver to perform HTTP-01 challenge - http01: ingress: class: nginx selector: {} Create a Certificate resource A Certificate is a namespaced resource that specifies fields that are used to generated certificate signing requests which are then fulfilled by the issuer type you have referenced. Certificates specify which issuer they want to obtain the certificate from by specifying the certificate.spec.issuerRef field. Once the Issuer is ready, you can create a Certificate resource which will send a request to issue a new certificate. --- apiVersion: cert-manager.io/v1alpha2 kind: Certificate metadata: name: dev.mydomain.com # Cert-manager will put the resulting Secret in the same Kubernetes # namespace as the Certificate. You should create the certificate in # whichever namespace you want to configure a Host. spec: secretName: dev.mydomain.com issuerRef: # Name of ClusterIssuer name: letsencrypt-prod kind: ClusterIssuer dnsNames: - dev.mydomain.com After applying this template, you should see the following events: $ kubectl get events -n default # The namespace in which you created your Certificate resource 14m Normal cert-manager.io certificaterequest/dev.mydomain.com-qrfxs Certificate request has been approved by cert-manager.io 14m Normal Issuing certificate/dev.mydomain.com Issuing certificate as Secret does not exist 14m Normal Generated certificate/dev.mydomain.com Stored new private key in temporary Secret resource &quot;dev.mydomain.com-lrdk6&quot; 14m Normal Requested certificate/dev.mydomain.com Created new CertificateRequest resource &quot;dev.mydomain.com-qrfxs&quot; 14m Normal Created order/dev.mydomain.com-qrfxs-820390478 Created Challenge resource &quot;dev.mydomain.com-qrfxs-820390478-3681158932&quot; for domain &quot;dev.mydomain.com&quot; &lt;unknown&gt; Normal Scheduled pod/cm-acme-http-solver-fbhcs Successfully assigned default/cm-acme-http-solver-fbhcs to the-name-of-some-node-1 14m Normal Presented challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Presented challenge using HTTP-01 challenge mechanism 14m Normal Started challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Challenge scheduled for processing 14m Normal Pulling pod/cm-acme-http-solver-fbhcs Pulling image &quot;quay.io/jetstack/cert-manager-acmesolver:v1.3.1&quot; 13m Normal Pulled pod/cm-acme-http-solver-fbhcs Successfully pulled image &quot;quay.io/jetstack/cert-manager-acmesolver:v1.3.1&quot; 13m Normal Started pod/cm-acme-http-solver-fbhcs Started container acmesolver 13m Normal Created pod/cm-acme-http-solver-fbhcs Created container acmesolver Create a Mapping and Service resource for HTTP challenge At this point, Cert-manager will have created a temporary pod named cm-acme-http-solver-xxxx but no certificate has been issued. You will need to create a Mapping resource to allow Ambassador to reach the http-01 challenge solver via http://dev.mydomain.com/.well-known/acme-challenge/&lt;some-token&gt;. --- apiVersion: getambassador.io/v2 kind: Mapping metadata: name: acme-challenge-mapping spec: prefix: /.well-known/acme-challenge/ rewrite: &quot;&quot; service: acme-challenge-service --- apiVersion: v1 kind: Service metadata: name: acme-challenge-service spec: ports: - port: 80 targetPort: 8089 selector: acme.cert-manager.io/http01-solver: &quot;true&quot; After applying the template, you will need to wait a several minutes (about 10 minutes) before cert-manager retries the challenge and issues a certificate. You should see the following events: $ kubectl get events -n default # The namespace in which you created your Certificate resource 6m38s Normal Killing pod/cm-acme-http-solver-fbhcs Stopping container acmesolver 6m38s Normal DomainVerified challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Domain &quot;dev.mydomain.com&quot; verified with &quot;HTTP-01&quot; validation 6m37s Normal Complete order/dev.mydomain.com-qrfxs-820390478 Order completed successfully 6m37s Normal Issuing certificate/dev.mydomain.com The certificate has been successfully issued 6m37s Normal CertificateIssued certificaterequest/dev.mydomain.com-qrfxs Certificate fetched from issuer successfully Create a Host resource for your domain name After the certificate was successfully issued, there should be a TLS secret called dev.mydomain.com(name is defined by secretName in the Certificate resource). Then, you can create a Host resource. It will register your ACME account, read the certificate from the TLS secret and use that to terminate TLS on your domain. --- apiVersion: getambassador.io/v2 kind: Host metadata: name: dev.mydomain.com namespace: default spec: acmeProvider: authority: &#39;https://acme-v02.api.letsencrypt.org/directory&#39; email: my-email@gmail.com ambassadorId: - default hostname: dev.mydomain.com selector: matchLabels: hostname: dev.mydomain.com tlsSecret: name: dev.mydomain.com # The secretName defined in your Certificate resource You should see the following events: $ kubectl get events -n default # The namespace in which you created your Host resource 10s Normal Pending host/dev.mydomain.com waiting for Host DefaultsFilled change to be reflected in snapshot 8s Normal Pending host/dev.mydomain.com creating private key Secret 8s Normal Pending host/dev.mydomain.com waiting for private key Secret creation to be reflected in snapshot 6s Normal Pending host/dev.mydomain.com waiting for Host status change to be reflected in snapshot 4s Normal Pending host/dev.mydomain.com registering ACME account 3s Normal Pending host/dev.mydomain.com waiting for Host ACME account registration change to be reflected in snapshot 3s Normal Pending host/dev.mydomain.com ACME account registered 1s Normal Pending host/dev.mydomain.com waiting for TLS Secret update to be reflected in snapshot 1s Normal Pending host/dev.mydomain.com updating TLS Secret 0s Normal Ready host/dev.mydomain.com Host with ACME-provisioned TLS certificate marked Ready Conclusion Ambassador Edge Stack automatically enables TLS termination/HTTPs and you can easily configure it to completely manage TLS by requesting a certificate from a Certificate Authority(CA) instead of generating and managing certificates yourself! 🐢 References Ambassador Transport Layer Security (TLS) Ambassador ACME Support Ambassador and Cert-Manager HTTP-01 Challenge"/> <meta property="og:description" content="At my current company Ormuco Inc., we use Ambassador Edge Stack (AES) as our Kubernetes-native API Gateway with HTTPS enabled and TLS termination. Until recently, we had been generating certificates using Certbot and renewing them with automated scripts. In this article, I will walk you through a better way to manage certificates in Kubernetes using Ambassador Edge Stack’s automatic TLS with ACME. Prerequisites This tutorial requires you have the following: A Kubernetes cluster A domain name Ambassador Edge Stack deployed in your cluster (see here) Your domain name pointing to the Ambassador LoadBalancer’s external IP What is Ambassador Automatic TLS? The Ambassador Edge Stack has simple and easy built-in support for automatically using ACME to create and renew TLS certificates; configured by the Host resource. However, it only supports ACME’s http-01 challenge; if you require more flexible certificate management (such as using ACME’s dns-01 challenge, or using a non-ACME certificate source), the Ambassador Edge stack also supports using external certificate management tools. One such tool is Jetstack’s cert-manager, which is a general-purpose tool for managing certificates in Kubernetes. Cert-manager will automatically create and renew TLS certificates and store them as Kubernetes secrets for easy use in a cluster. The Ambassador Edge Stack will automatically watch for secret changes and reload certificates upon renewal. Essentially, we can deploy Cert-Manager to manage certificates in Kubernetes for us. Ambassador only supports HTTP-01 challenge but it’s possible to perform DNS-01 challenge using Cert-Manager. Note: We use GoDaddy domain names and it is not a supported DNS Provider (see list of supported providers). There are several Cert-Manager Godaddy Webhook implementations online but they don’t seem to be well maintained so I decided to stick with HTTP-01 challenge. How to Setup Automatic TLS with ACME? For tutorial, I will be using an arbitrary email my-email@gmail.com and Let’s Encrypt to Issue a certificate for an arbitrary domain name dev.mydomain.com. Install the Cert-Manager tool with kubectl Let’s start by installing the Cert-Manager tool that will manage our certificates. # Install Custom Resource Definitions and Cert-Manager kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml Note: You can also install Cert-Manager with Helm (see here) Create a ClusterIssuer resource An Issuer or ClusterIssuer identifies which Certificate Authority cert-manager will use to issue a certificate. Issuer is a namespaced resource allowing you to use different CAs in each namespace, a ClusterIssuer is used to issue certificates in any namespace. Configuration depends on which ACME challenge you are using. Once the Cert-manager deployments are completed, you can create a ClusterIssuer (global) or an Issuer (namespaced) resource. In this case, we are using Let’s Encrypt. --- apiVersion: cert-manager.io/v1alpha2 kind: ClusterIssuer metadata: name: letsencrypt-prod spec: acme: # Replace this email address with your own. # Let&#39;s Encrypt will use this to contact you about expiring # certificates, and issues related to your account. email: my-email@gmail.com # ACME URL, you can use the URL for Staging environment to Issue untrusted certificates server: https://acme-v02.api.letsencrypt.org/directory privateKeySecretRef: # Secret resource that will be used to store the account&#39;s private key. name: issuer-account-private-key solvers: # Define the solver to perform HTTP-01 challenge - http01: ingress: class: nginx selector: {} Create a Certificate resource A Certificate is a namespaced resource that specifies fields that are used to generated certificate signing requests which are then fulfilled by the issuer type you have referenced. Certificates specify which issuer they want to obtain the certificate from by specifying the certificate.spec.issuerRef field. Once the Issuer is ready, you can create a Certificate resource which will send a request to issue a new certificate. --- apiVersion: cert-manager.io/v1alpha2 kind: Certificate metadata: name: dev.mydomain.com # Cert-manager will put the resulting Secret in the same Kubernetes # namespace as the Certificate. You should create the certificate in # whichever namespace you want to configure a Host. spec: secretName: dev.mydomain.com issuerRef: # Name of ClusterIssuer name: letsencrypt-prod kind: ClusterIssuer dnsNames: - dev.mydomain.com After applying this template, you should see the following events: $ kubectl get events -n default # The namespace in which you created your Certificate resource 14m Normal cert-manager.io certificaterequest/dev.mydomain.com-qrfxs Certificate request has been approved by cert-manager.io 14m Normal Issuing certificate/dev.mydomain.com Issuing certificate as Secret does not exist 14m Normal Generated certificate/dev.mydomain.com Stored new private key in temporary Secret resource &quot;dev.mydomain.com-lrdk6&quot; 14m Normal Requested certificate/dev.mydomain.com Created new CertificateRequest resource &quot;dev.mydomain.com-qrfxs&quot; 14m Normal Created order/dev.mydomain.com-qrfxs-820390478 Created Challenge resource &quot;dev.mydomain.com-qrfxs-820390478-3681158932&quot; for domain &quot;dev.mydomain.com&quot; &lt;unknown&gt; Normal Scheduled pod/cm-acme-http-solver-fbhcs Successfully assigned default/cm-acme-http-solver-fbhcs to the-name-of-some-node-1 14m Normal Presented challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Presented challenge using HTTP-01 challenge mechanism 14m Normal Started challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Challenge scheduled for processing 14m Normal Pulling pod/cm-acme-http-solver-fbhcs Pulling image &quot;quay.io/jetstack/cert-manager-acmesolver:v1.3.1&quot; 13m Normal Pulled pod/cm-acme-http-solver-fbhcs Successfully pulled image &quot;quay.io/jetstack/cert-manager-acmesolver:v1.3.1&quot; 13m Normal Started pod/cm-acme-http-solver-fbhcs Started container acmesolver 13m Normal Created pod/cm-acme-http-solver-fbhcs Created container acmesolver Create a Mapping and Service resource for HTTP challenge At this point, Cert-manager will have created a temporary pod named cm-acme-http-solver-xxxx but no certificate has been issued. You will need to create a Mapping resource to allow Ambassador to reach the http-01 challenge solver via http://dev.mydomain.com/.well-known/acme-challenge/&lt;some-token&gt;. --- apiVersion: getambassador.io/v2 kind: Mapping metadata: name: acme-challenge-mapping spec: prefix: /.well-known/acme-challenge/ rewrite: &quot;&quot; service: acme-challenge-service --- apiVersion: v1 kind: Service metadata: name: acme-challenge-service spec: ports: - port: 80 targetPort: 8089 selector: acme.cert-manager.io/http01-solver: &quot;true&quot; After applying the template, you will need to wait a several minutes (about 10 minutes) before cert-manager retries the challenge and issues a certificate. You should see the following events: $ kubectl get events -n default # The namespace in which you created your Certificate resource 6m38s Normal Killing pod/cm-acme-http-solver-fbhcs Stopping container acmesolver 6m38s Normal DomainVerified challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Domain &quot;dev.mydomain.com&quot; verified with &quot;HTTP-01&quot; validation 6m37s Normal Complete order/dev.mydomain.com-qrfxs-820390478 Order completed successfully 6m37s Normal Issuing certificate/dev.mydomain.com The certificate has been successfully issued 6m37s Normal CertificateIssued certificaterequest/dev.mydomain.com-qrfxs Certificate fetched from issuer successfully Create a Host resource for your domain name After the certificate was successfully issued, there should be a TLS secret called dev.mydomain.com(name is defined by secretName in the Certificate resource). Then, you can create a Host resource. It will register your ACME account, read the certificate from the TLS secret and use that to terminate TLS on your domain. --- apiVersion: getambassador.io/v2 kind: Host metadata: name: dev.mydomain.com namespace: default spec: acmeProvider: authority: &#39;https://acme-v02.api.letsencrypt.org/directory&#39; email: my-email@gmail.com ambassadorId: - default hostname: dev.mydomain.com selector: matchLabels: hostname: dev.mydomain.com tlsSecret: name: dev.mydomain.com # The secretName defined in your Certificate resource You should see the following events: $ kubectl get events -n default # The namespace in which you created your Host resource 10s Normal Pending host/dev.mydomain.com waiting for Host DefaultsFilled change to be reflected in snapshot 8s Normal Pending host/dev.mydomain.com creating private key Secret 8s Normal Pending host/dev.mydomain.com waiting for private key Secret creation to be reflected in snapshot 6s Normal Pending host/dev.mydomain.com waiting for Host status change to be reflected in snapshot 4s Normal Pending host/dev.mydomain.com registering ACME account 3s Normal Pending host/dev.mydomain.com waiting for Host ACME account registration change to be reflected in snapshot 3s Normal Pending host/dev.mydomain.com ACME account registered 1s Normal Pending host/dev.mydomain.com waiting for TLS Secret update to be reflected in snapshot 1s Normal Pending host/dev.mydomain.com updating TLS Secret 0s Normal Ready host/dev.mydomain.com Host with ACME-provisioned TLS certificate marked Ready Conclusion Ambassador Edge Stack automatically enables TLS termination/HTTPs and you can easily configure it to completely manage TLS by requesting a certificate from a Certificate Authority(CA) instead of generating and managing certificates yourself! 🐢 References Ambassador Transport Layer Security (TLS) Ambassador ACME Support Ambassador and Cert-Manager HTTP-01 Challenge"/> <link rel="canonical" href="https://uace.github.io/tutorial/how-to-setup-ambassador-edge-stack-s-automatic-tls-with-acme"/> <meta property="og:url" content="https://uace.github.io/tutorial/how-to-setup-ambassador-edge-stack-s-automatic-tls-with-acme"/> <meta property="og:site_name" content="UAce"/> <meta property="og:type" content="article"/> <meta property="article:published_time" content="2021-04-13T04:14:00+00:00"/> <meta name="twitter:card" content="summary"/> <meta property="twitter:title" content="How to Setup Ambassador Edge Stack’s Automatic TLS with ACME"/> <script type="application/ld+json">
{"description":"At my current company Ormuco Inc., we use Ambassador Edge Stack (AES) as our Kubernetes-native API Gateway with HTTPS enabled and TLS termination. Until recently, we had been generating certificates using Certbot and renewing them with automated scripts. In this article, I will walk you through a better way to manage certificates in Kubernetes using Ambassador Edge Stack’s automatic TLS with ACME. Prerequisites This tutorial requires you have the following: A Kubernetes cluster A domain name Ambassador Edge Stack deployed in your cluster (see here) Your domain name pointing to the Ambassador LoadBalancer’s external IP What is Ambassador Automatic TLS? The Ambassador Edge Stack has simple and easy built-in support for automatically using ACME to create and renew TLS certificates; configured by the Host resource. However, it only supports ACME’s http-01 challenge; if you require more flexible certificate management (such as using ACME’s dns-01 challenge, or using a non-ACME certificate source), the Ambassador Edge stack also supports using external certificate management tools. One such tool is Jetstack’s cert-manager, which is a general-purpose tool for managing certificates in Kubernetes. Cert-manager will automatically create and renew TLS certificates and store them as Kubernetes secrets for easy use in a cluster. The Ambassador Edge Stack will automatically watch for secret changes and reload certificates upon renewal. Essentially, we can deploy Cert-Manager to manage certificates in Kubernetes for us. Ambassador only supports HTTP-01 challenge but it’s possible to perform DNS-01 challenge using Cert-Manager. Note: We use GoDaddy domain names and it is not a supported DNS Provider (see list of supported providers). There are several Cert-Manager Godaddy Webhook implementations online but they don’t seem to be well maintained so I decided to stick with HTTP-01 challenge. How to Setup Automatic TLS with ACME? For tutorial, I will be using an arbitrary email my-email@gmail.com and Let’s Encrypt to Issue a certificate for an arbitrary domain name dev.mydomain.com. Install the Cert-Manager tool with kubectl Let’s start by installing the Cert-Manager tool that will manage our certificates. # Install Custom Resource Definitions and Cert-Manager kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml Note: You can also install Cert-Manager with Helm (see here) Create a ClusterIssuer resource An Issuer or ClusterIssuer identifies which Certificate Authority cert-manager will use to issue a certificate. Issuer is a namespaced resource allowing you to use different CAs in each namespace, a ClusterIssuer is used to issue certificates in any namespace. Configuration depends on which ACME challenge you are using. Once the Cert-manager deployments are completed, you can create a ClusterIssuer (global) or an Issuer (namespaced) resource. In this case, we are using Let’s Encrypt. --- apiVersion: cert-manager.io/v1alpha2 kind: ClusterIssuer metadata: name: letsencrypt-prod spec: acme: # Replace this email address with your own. # Let&#39;s Encrypt will use this to contact you about expiring # certificates, and issues related to your account. email: my-email@gmail.com # ACME URL, you can use the URL for Staging environment to Issue untrusted certificates server: https://acme-v02.api.letsencrypt.org/directory privateKeySecretRef: # Secret resource that will be used to store the account&#39;s private key. name: issuer-account-private-key solvers: # Define the solver to perform HTTP-01 challenge - http01: ingress: class: nginx selector: {} Create a Certificate resource A Certificate is a namespaced resource that specifies fields that are used to generated certificate signing requests which are then fulfilled by the issuer type you have referenced. Certificates specify which issuer they want to obtain the certificate from by specifying the certificate.spec.issuerRef field. Once the Issuer is ready, you can create a Certificate resource which will send a request to issue a new certificate. --- apiVersion: cert-manager.io/v1alpha2 kind: Certificate metadata: name: dev.mydomain.com # Cert-manager will put the resulting Secret in the same Kubernetes # namespace as the Certificate. You should create the certificate in # whichever namespace you want to configure a Host. spec: secretName: dev.mydomain.com issuerRef: # Name of ClusterIssuer name: letsencrypt-prod kind: ClusterIssuer dnsNames: - dev.mydomain.com After applying this template, you should see the following events: $ kubectl get events -n default # The namespace in which you created your Certificate resource 14m Normal cert-manager.io certificaterequest/dev.mydomain.com-qrfxs Certificate request has been approved by cert-manager.io 14m Normal Issuing certificate/dev.mydomain.com Issuing certificate as Secret does not exist 14m Normal Generated certificate/dev.mydomain.com Stored new private key in temporary Secret resource &quot;dev.mydomain.com-lrdk6&quot; 14m Normal Requested certificate/dev.mydomain.com Created new CertificateRequest resource &quot;dev.mydomain.com-qrfxs&quot; 14m Normal Created order/dev.mydomain.com-qrfxs-820390478 Created Challenge resource &quot;dev.mydomain.com-qrfxs-820390478-3681158932&quot; for domain &quot;dev.mydomain.com&quot; &lt;unknown&gt; Normal Scheduled pod/cm-acme-http-solver-fbhcs Successfully assigned default/cm-acme-http-solver-fbhcs to the-name-of-some-node-1 14m Normal Presented challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Presented challenge using HTTP-01 challenge mechanism 14m Normal Started challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Challenge scheduled for processing 14m Normal Pulling pod/cm-acme-http-solver-fbhcs Pulling image &quot;quay.io/jetstack/cert-manager-acmesolver:v1.3.1&quot; 13m Normal Pulled pod/cm-acme-http-solver-fbhcs Successfully pulled image &quot;quay.io/jetstack/cert-manager-acmesolver:v1.3.1&quot; 13m Normal Started pod/cm-acme-http-solver-fbhcs Started container acmesolver 13m Normal Created pod/cm-acme-http-solver-fbhcs Created container acmesolver Create a Mapping and Service resource for HTTP challenge At this point, Cert-manager will have created a temporary pod named cm-acme-http-solver-xxxx but no certificate has been issued. You will need to create a Mapping resource to allow Ambassador to reach the http-01 challenge solver via http://dev.mydomain.com/.well-known/acme-challenge/&lt;some-token&gt;. --- apiVersion: getambassador.io/v2 kind: Mapping metadata: name: acme-challenge-mapping spec: prefix: /.well-known/acme-challenge/ rewrite: &quot;&quot; service: acme-challenge-service --- apiVersion: v1 kind: Service metadata: name: acme-challenge-service spec: ports: - port: 80 targetPort: 8089 selector: acme.cert-manager.io/http01-solver: &quot;true&quot; After applying the template, you will need to wait a several minutes (about 10 minutes) before cert-manager retries the challenge and issues a certificate. You should see the following events: $ kubectl get events -n default # The namespace in which you created your Certificate resource 6m38s Normal Killing pod/cm-acme-http-solver-fbhcs Stopping container acmesolver 6m38s Normal DomainVerified challenge/dev.mydomain.com-qrfxs-820390478-3681158932 Domain &quot;dev.mydomain.com&quot; verified with &quot;HTTP-01&quot; validation 6m37s Normal Complete order/dev.mydomain.com-qrfxs-820390478 Order completed successfully 6m37s Normal Issuing certificate/dev.mydomain.com The certificate has been successfully issued 6m37s Normal CertificateIssued certificaterequest/dev.mydomain.com-qrfxs Certificate fetched from issuer successfully Create a Host resource for your domain name After the certificate was successfully issued, there should be a TLS secret called dev.mydomain.com(name is defined by secretName in the Certificate resource). Then, you can create a Host resource. It will register your ACME account, read the certificate from the TLS secret and use that to terminate TLS on your domain. --- apiVersion: getambassador.io/v2 kind: Host metadata: name: dev.mydomain.com namespace: default spec: acmeProvider: authority: &#39;https://acme-v02.api.letsencrypt.org/directory&#39; email: my-email@gmail.com ambassadorId: - default hostname: dev.mydomain.com selector: matchLabels: hostname: dev.mydomain.com tlsSecret: name: dev.mydomain.com # The secretName defined in your Certificate resource You should see the following events: $ kubectl get events -n default # The namespace in which you created your Host resource 10s Normal Pending host/dev.mydomain.com waiting for Host DefaultsFilled change to be reflected in snapshot 8s Normal Pending host/dev.mydomain.com creating private key Secret 8s Normal Pending host/dev.mydomain.com waiting for private key Secret creation to be reflected in snapshot 6s Normal Pending host/dev.mydomain.com waiting for Host status change to be reflected in snapshot 4s Normal Pending host/dev.mydomain.com registering ACME account 3s Normal Pending host/dev.mydomain.com waiting for Host ACME account registration change to be reflected in snapshot 3s Normal Pending host/dev.mydomain.com ACME account registered 1s Normal Pending host/dev.mydomain.com waiting for TLS Secret update to be reflected in snapshot 1s Normal Pending host/dev.mydomain.com updating TLS Secret 0s Normal Ready host/dev.mydomain.com Host with ACME-provisioned TLS certificate marked Ready Conclusion Ambassador Edge Stack automatically enables TLS termination/HTTPs and you can easily configure it to completely manage TLS by requesting a certificate from a Certificate Authority(CA) instead of generating and managing certificates yourself! 🐢 References Ambassador Transport Layer Security (TLS) Ambassador ACME Support Ambassador and Cert-Manager HTTP-01 Challenge","author":{"@type":"Person","name":"Yu-Yueh Liu"},"@type":"BlogPosting","url":"https://uace.github.io/tutorial/how-to-setup-ambassador-edge-stack-s-automatic-tls-with-acme","headline":"How to Setup Ambassador Edge Stack’s Automatic TLS with ACME","dateModified":"2021-04-13T04:14:00+00:00","datePublished":"2021-04-13T04:14:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uace.github.io/tutorial/how-to-setup-ambassador-edge-stack-s-automatic-tls-with-acme"},"@context":"https://schema.org"}</script> </head> <body> <link rel="icon" id="light-favicon" href="/assets/images/UA_favicon_light.svg" type="image/svg"/> <link rel="icon" id="dark-favicon" href="/assets/images/UA_favicon_dark.svg" type="image/svg"/> <button id="scroll-to-top" title="Scroll to top">Top</button> <nav id="navbar" class="navbar fixed-top navbar-expand-sm justify-content-between"> <div class="container"> <a class="navbar-brand mb-0 h1 add-margin-left-normal add-padding-bottom-small" href="/"> <img src="/assets/images/UA_favicon_dark.svg" width="40" height="30" class="d-inline-block home-logo favicon" alt="UA"> <span class="home-title">UAce</span> </a> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation" onclick="toggleNavbar()"> <span class="navbar-toggler-icon"></span> </button> <div class="collapse navbar-collapse" id="navbarNavAltMarkup"> <div class="navbar-nav nav nav-pills ml-auto text-right"> <a class="nav-item nav-link " id="tab-Articles" href="/articles">Articles</a> <a class="nav-item nav-link " id="tab-Resume" href="/resume">Resume</a> <a class="nav-item nav-link " id="tab-About me" href="/about">About me</a> <a id="theme-icon-wrapper" onclick="modeSwitcher()"><i id="theme-icon" class="icon fas fa-lg"></i></a> </div> </div> </div> </nav> <main class="main-body"> <article class="container post-container"> <header class="post-header"> <h1 class="post-title">How to Setup Ambassador Edge Stack&#39;s Automatic TLS with ACME</h1> <p class="post-meta"> <a href="/about#me"> <img src="/assets/images/yueh.png" width="48" height="48" class="icon-avatar img-fluid img-thumbnail" alt="Me"> </a> <time class="post-datetime" datetime="2021-04-13T04:14:00+00:00">Apr 13, 2021 </time> <span class="bullet-before"> </span><i class="far fa-clock"></i> 9 min to read </p> <span class="post-tags"> <a href="/tags/Ambassador Edge Stack" class="tag" data-proofer-ignore> <span>Ambassador Edge Stack</span> </a> <a href="/tags/Kubernetes" class="tag" data-proofer-ignore> <span>Kubernetes</span> </a> <a href="/tags/DevOps" class="tag" data-proofer-ignore> <span>DevOps</span> </a> </span> </header> <div class="post-body"> <p>At my current company Ormuco Inc., we use <strong>Ambassador Edge Stack</strong> (<a href="https://www.getambassador.io/">AES</a>) as our Kubernetes-native API Gateway with HTTPS enabled and TLS termination. Until recently, we had been generating certificates using <strong>Certbot</strong> and renewing them with automated scripts.</p> <p>In this article, I will walk you through a better way to manage certificates in Kubernetes using Ambassador Edge Stack’s automatic TLS with ACME.</p> <h2 id="prerequisites">Prerequisites</h2> <p>This tutorial requires you have the following:</p> <ul> <li>A Kubernetes cluster</li> <li>A domain name</li> <li>Ambassador Edge Stack deployed in your cluster (see <a href="https://www.getambassador.io/docs/edge-stack/latest/topics/install/#img-classos-logo-srcimageskubernetespng-install-via-kubernetes-yaml">here</a>)</li> <li>Your domain name pointing to the Ambassador LoadBalancer’s external IP</li> </ul> <h2 id="what-is-ambassador-automatic-tls">What is Ambassador Automatic TLS?</h2> <blockquote> <p>The <strong>Ambassador Edge Stack</strong> has simple and easy built-in support for automatically using ACME to create and renew TLS certificates; configured by the Host resource. However, it only supports ACME’s <strong>http-01 challenge</strong>; if you require more flexible certificate management (such as using ACME’s <strong>dns-01 challenge</strong>, or using a non-ACME certificate source), the Ambassador Edge stack also supports using external certificate management tools.</p> <p>One such tool is <strong>Jetstack</strong>’s cert-manager, which is a general-purpose tool for managing certificates in Kubernetes. Cert-manager will automatically create and renew TLS certificates and store them as Kubernetes secrets for easy use in a cluster. The Ambassador Edge Stack will automatically watch for secret changes and reload certificates upon renewal.</p> </blockquote> <p>Essentially, we can deploy Cert-Manager to manage certificates in Kubernetes for us. Ambassador only supports HTTP-01 challenge but it’s possible to perform DNS-01 challenge using Cert-Manager.</p> <p><em><strong>Note</strong>: We use GoDaddy domain names and it is not a supported DNS Provider (see <a href="https://cert-manager.io/docs/configuration/acme/dns01/#supported-dns01-providers">list of supported providers</a>). There are several Cert-Manager Godaddy Webhook implementations online but they don’t seem to be well maintained so I decided to stick with HTTP-01 challenge.</em></p> <h2 id="how-to-setup-automatic-tls-with-acme">How to Setup Automatic TLS with ACME?</h2> <p>For tutorial, I will be using an arbitrary email <ins>my-email@gmail.com</ins> and <strong>Let’s Encrypt</strong> to Issue a certificate for an arbitrary domain name <ins>dev.mydomain.com</ins>.</p> <h4 id="install-the-cert-manager-tool-with-kubectl">Install the Cert-Manager tool with kubectl</h4> <p>Let’s start by installing the Cert-Manager tool that will manage our certificates.</p> <pre><code class="language-Bash"># Install Custom Resource Definitions and Cert-Manager
kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml
</code></pre> <p><em><strong>Note</strong>: You can also install Cert-Manager with Helm (see <a href="https://cert-manager.io/docs/installation/kubernetes/#installing-with-helm">here</a>)</em></p> <h4 id="create-a-clusterissuer-resource">Create a ClusterIssuer resource</h4> <blockquote> <p>An Issuer or ClusterIssuer identifies which Certificate Authority cert-manager will use to issue a certificate. Issuer is a namespaced resource allowing you to use different CAs in each namespace, a ClusterIssuer is used to issue certificates in any namespace. Configuration depends on which ACME challenge you are using.</p> </blockquote> <p>Once the Cert-manager deployments are completed, you can create a ClusterIssuer (global) or an Issuer (namespaced) resource. In this case, we are using <strong>Let’s Encrypt</strong>.</p> <pre><code class="language-YAML">---
apiVersion: cert-manager.io/v1alpha2
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    # Replace this email address with your own.
    # Let's Encrypt will use this to contact you about expiring
    # certificates, and issues related to your account.
    email: my-email@gmail.com
    # ACME URL, you can use the URL for Staging environment to Issue untrusted certificates
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      # Secret resource that will be used to store the account's private key.
      name: issuer-account-private-key
    solvers:
    # Define the solver to perform HTTP-01 challenge
    - http01:
        ingress:
          class: nginx
      selector: {}
</code></pre> <h4 id="create-a-certificate-resource">Create a Certificate resource</h4> <blockquote> <p>A Certificate is a namespaced resource that specifies fields that are used to generated certificate signing requests which are then fulfilled by the issuer type you have referenced. Certificates specify which issuer they want to obtain the certificate from by specifying the certificate.spec.issuerRef field.</p> </blockquote> <p>Once the Issuer is ready, you can create a Certificate resource which will send a request to issue a new certificate.</p> <pre><code class="language-YAML">---
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: dev.mydomain.com
  # Cert-manager will put the resulting Secret in the same Kubernetes 
  # namespace as the Certificate. You should create the certificate in 
  # whichever namespace you want to configure a Host.
spec:
  secretName: dev.mydomain.com
  issuerRef:
    # Name of ClusterIssuer
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
  - dev.mydomain.com
</code></pre> <p>After applying this template, you should see the following events:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="gp">$</span><span class="w"> </span>kubectl get events <span class="nt">-n</span> default <span class="c"># The namespace in which you created your Certificate resource</span>
<span class="go">14m         Normal    cert-manager.io     certificaterequest/dev.mydomain.com-qrfxs               Certificate request has been approved by cert-manager.io
14m         Normal    Issuing             certificate/dev.mydomain.com                            Issuing certificate as Secret does not exist
14m         Normal    Generated           certificate/dev.mydomain.com                            Stored new private key in temporary Secret resource "dev.mydomain.com-lrdk6"
14m         Normal    Requested           certificate/dev.mydomain.com                            Created new CertificateRequest resource "dev.mydomain.com-qrfxs"
14m         Normal    Created             order/dev.mydomain.com-qrfxs-820390478                  Created Challenge resource "dev.mydomain.com-qrfxs-820390478-3681158932" for domain "dev.mydomain.com"
</span><span class="gp">&lt;unknown&gt;</span><span class="w">   </span>Normal    Scheduled           pod/cm-acme-http-solver-fbhcs                           Successfully assigned default/cm-acme-http-solver-fbhcs to the-name-of-some-node-1
<span class="go">14m         Normal    Presented           challenge/dev.mydomain.com-qrfxs-820390478-3681158932   Presented challenge using HTTP-01 challenge mechanism
14m         Normal    Started             challenge/dev.mydomain.com-qrfxs-820390478-3681158932   Challenge scheduled for processing
14m         Normal    Pulling             pod/cm-acme-http-solver-fbhcs                           Pulling image "quay.io/jetstack/cert-manager-acmesolver:v1.3.1"
13m         Normal    Pulled              pod/cm-acme-http-solver-fbhcs                           Successfully pulled image "quay.io/jetstack/cert-manager-acmesolver:v1.3.1"
13m         Normal    Started             pod/cm-acme-http-solver-fbhcs                           Started container acmesolver
13m         Normal    Created             pod/cm-acme-http-solver-fbhcs                           Created container acmesolver
</span></code></pre></div></div> <h4 id="create-a-mapping-and-service-resource-for-http-challenge">Create a Mapping and Service resource for HTTP challenge</h4> <p>At this point, Cert-manager will have created a temporary pod named <code class="language-html highlighter-rouge">cm-acme-http-solver-xxxx</code> but no certificate has been issued. You will need to create a Mapping resource to allow Ambassador to reach the http-01 challenge solver via <code class="language-html highlighter-rouge">http://dev.mydomain.com/.well-known/acme-challenge/<span class="nt">&lt;some-token&gt;</span></code>.</p> <pre><code class="language-YAML">---
apiVersion: getambassador.io/v2
kind: Mapping
metadata:
  name: acme-challenge-mapping
spec:
  prefix: /.well-known/acme-challenge/
  rewrite: ""
  service: acme-challenge-service
---
apiVersion: v1
kind: Service
metadata:
  name: acme-challenge-service
spec:
  ports:
  - port: 80
    targetPort: 8089
  selector:
    acme.cert-manager.io/http01-solver: "true"
</code></pre> <p>After applying the template, you will need to wait a several minutes (about 10 minutes) before cert-manager retries the challenge and issues a certificate. You should see the following events:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="gp">$</span><span class="w"> </span>kubectl get events <span class="nt">-n</span> default <span class="c"># The namespace in which you created your Certificate resource</span>
<span class="go">6m38s       Normal    Killing             pod/cm-acme-http-solver-fbhcs                           Stopping container acmesolver
6m38s       Normal    DomainVerified      challenge/dev.mydomain.com-qrfxs-820390478-3681158932   Domain "dev.mydomain.com" verified with "HTTP-01" validation
6m37s       Normal    Complete            order/dev.mydomain.com-qrfxs-820390478                  Order completed successfully
6m37s       Normal    Issuing             certificate/dev.mydomain.com                            The certificate has been successfully issued
6m37s       Normal    CertificateIssued   certificaterequest/dev.mydomain.com-qrfxs               Certificate fetched from issuer successfully
</span></code></pre></div></div> <h4 id="create-a-host-resource-for-your-domain-name">Create a Host resource for your domain name</h4> <p>After the certificate was successfully issued, there should be a TLS secret called <code class="language-html highlighter-rouge">dev.mydomain.com</code>(name is defined by <strong>secretName</strong> in the Certificate resource). Then, you can create a Host resource. It will register your ACME account, read the certificate from the TLS secret and use that to terminate TLS on your domain.</p> <pre><code class="language-YAML">---
apiVersion: getambassador.io/v2
kind: Host
metadata:
  name: dev.mydomain.com
  namespace: default
spec:
  acmeProvider:
    authority: 'https://acme-v02.api.letsencrypt.org/directory'
    email: my-email@gmail.com
  ambassadorId:
    - default
  hostname: dev.mydomain.com
  selector:
    matchLabels:
      hostname: dev.mydomain.com
  tlsSecret:
    name: dev.mydomain.com # The secretName defined in your Certificate resource
</code></pre> <p>You should see the following events:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="gp">$</span><span class="w"> </span>kubectl get events <span class="nt">-n</span> default <span class="c"># The namespace in which you created your Host resource</span>
<span class="go">10s      Normal    Pending        host/dev.mydomain.com        waiting for Host DefaultsFilled change to be reflected in snapshot
8s       Normal    Pending        host/dev.mydomain.com        creating private key Secret
8s       Normal    Pending        host/dev.mydomain.com        waiting for private key Secret creation to be reflected in snapshot
6s       Normal    Pending        host/dev.mydomain.com        waiting for Host status change to be reflected in snapshot
4s       Normal    Pending        host/dev.mydomain.com        registering ACME account
3s       Normal    Pending        host/dev.mydomain.com        waiting for Host ACME account registration change to be reflected in snapshot
3s       Normal    Pending        host/dev.mydomain.com        ACME account registered
1s       Normal    Pending        host/dev.mydomain.com        waiting for TLS Secret update to be reflected in snapshot
1s       Normal    Pending        host/dev.mydomain.com        updating TLS Secret
0s       Normal    Ready          host/dev.mydomain.com        Host with ACME-provisioned TLS certificate marked Ready
</span></code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>Ambassador Edge Stack automatically enables TLS termination/HTTPs and you can easily configure it to completely manage TLS by requesting a certificate from a Certificate Authority(CA) instead of generating and managing certificates yourself!</p> <p>🐢</p> <h2 id="references">References</h2> <ul> <li><strong><a href="https://www.getambassador.io/docs/edge-stack/latest/topics/running/tls/">Ambassador Transport Layer Security (TLS)</a></strong></li> <li><strong><a href="https://www.getambassador.io/docs/edge-stack/latest/topics/running/host-crd">Ambassador ACME Support</a></strong></li> <li><strong><a href="https://www.getambassador.io/docs/edge-stack/latest/howtos/cert-manager/#http-01-challenge">Ambassador and Cert-Manager HTTP-01 Challenge</a></strong></li> </ul> </div> </article> </main> <footer> <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script> <script src="/assets/js/common.js"></script> <script src="/assets/js/theme-switcher.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js" integrity="sha384-ujbKXb9V3HdK7jcWL6kHL1c+2Lj4MR4Gkjl7UtwpSHg/ClpViddK9TI7yU53frPN" crossorigin="anonymous"></script> <div class="row align-items-center"> <span class="col-md-12 text-center"> © 2020 Yu-Yueh Liu ｜ <a href="https://www.youtube.com/watch?v=XvR-kTUad6U" target="_blank">Plus Ultra</a> ｜ <a href="feed.xml" data-proofer-ignore>RSS <i class="fas fa-rss"></i></a> ｜ <a href="sitemap.xml" data-proofer-ignore>Sitemap</a> ｜ <a href='https://ko-fi.com/U7U43SBW4' target='_blank'><img height='30' style='border:0px;height:30px;' src='https://cdn.ko-fi.com/cdn/kofi5.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com'/></a> </span> </div> </footer> </body> </html>